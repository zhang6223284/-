[TOC]

# 计算机基础知识

##### 1.线程和进程的区别

* 一个程序至少有一个进程，一个进程至少有一个线程。
* 线程的划分程度小于进程，使得多线程程序的并发性高。
* 另外，进程在执行过程中有独立的内存单元，而多个线程共享内存，从而极大的提高了程序的运行效率。
* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须已存在应用程序中，有应用程序提供多个线程执行控制。
* 从逻辑角度来讲，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

##### 2.请说出三种减少页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）

1. 优化图片

2. 图像格式的选择（GIF 提供的颜色较少，可用在一些对颜色要求不高的地方）

3. 优化 CSS（压缩合并 CSS，如 margin-top，margin-left 等）

4. 网址后加斜杠（对服务器而言，不加斜杠服务器会多一次判断过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面）

5. 标明图片的高度和宽度

6. 减少 HTTP 请求，（合并文件，合并请求）

##### 3.解释下原型继承的原理

当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。

首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值，如果没有找到，则继续搜索指针指向的远行对象，在原型对象中查找具有给定名字的属性。

以下代码展示了 JS 引擎如何查找属性：

``` javascript

function getProperty(obj, prop) {

    if (obj.hasOwnProperty(prop))

        return obj[prop]

    else if (obj.__proto__ !== null)

        return getProperty(obj.__proto__, prop)

    else
        
        return undefined
    
}
```

##### 4.在浏览器那里输入一个网址，会发生什么

> * 第一步 浏览器查找该域名的 IP 地址
> * 第二步 浏览器根据解析得到的 IP 地址向 web 服务器发送一个 HTTP 请求
> * 第三步 服务器收到请求并进行处理
> * 第四步 服务器返回一个响应
> * 第五步 浏览器对该响应进行解码，渲染显示
> * 第六步 页面显示完成后，浏览器发送异步请求

1. 域名解析：浏览器获得 URL 地址，向操作系统请求该 URL 对应的 IP 地址，操作系统查询 DNS（首先查询本地 HOST 文件，没有则查询网络）获得对应的 IP 地址。

   解释：

   把 URL 分割成几个部分：协议、网络地址、资源路径

   协议：指从该计算机获取资源的方式，常见的是 HTTP、FTP

   网络地址：可以是域名或者是 IP 地址，也可以包括端口号，如果不注明端口号，默认是 80 端口

   如果地址不是一个 IP 地址，则需要通过 DNS（域名系统）将该地址解析成 IP 地址，IP 地址对应着网络上的一台计算机，DNS 服务器本身也有 IP，你的网络设置包含 DNS 服务器的 IP，例如，www.abc.com 不是一个 IP，则需要向 DNS 询问请求  www.abc.com 对应的 IP，获得 IP，在这个过程中，你的电脑直接询问 DNS 服务器可能没有发现 www.abc.com 对应的 IP，就会向它的上级服务器询问，这样依次一层层向上级找，最高可达根节点，直到找到或者全部找不到为止

   端口号就相当于银行的窗口，不同的窗口负责不同的服务，如果输入 www.abc.com:8080/，则表示不使用默认的 80 端口，而使用指定的 8080 端口

2. 确认好了 IP 和端口号，则可以向该 IP 地址对应的服务器的该端口号发起 TCP 连接请求

3. 服务器接收到 TCP 连接请求后，回复可以连接请求

4. 浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束

5. 三次握手成功后，开始通讯，根据 HTTP 协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等，例如，www.abc.com/images/1/ 表示的资源路径是 images/1/，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链 URL 地址，重复上述步骤，再次获取

6. 渲染页面，并开始响应用户的操作

7. 窗口关闭时，浏览器终止与服务器的连接

##### 5.TCP 和三次握手四次挥手

TCP 表示传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。

TCP/IP 即传输控制协议/网间协议，是为广域网设计的。

TCP 三次握手和四次挥手。

TCP 三次握手：

所谓的三次握手，是指建立一个 TCP 连接时，需要客户端和服务器端总共发送三个包，三次握手的目的是连接服务器的指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息，在 SOCKET 编程中，客户端执行 connect() 时，将会触发三次握手

![](https://img-blog.csdn.net/20160309093354101)

解释：

ACK：TCP 协议规定，只有 ACK = 1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为1

SYN：在连接建立时用来同步序号，当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使 SYN = 1 和 ACK = 1，因此，SYN 置 1 就表示这是一个连接请求或连接接受报文

FIN：即终结的意思，用来释放一个连接，当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接

为什么要进行三次握手（两次确认）？

主要是为了防止客户端发出的已失效的连接请求报文段突然又传送到了服务器端，因而产生错误，考虑一种正常情况，A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求，后来收到了确认，建立了连接，数据传输完毕后，就释放了连接，A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，正常，再考虑一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B，本来这是一个早已失效的报文段，但 B 收到此失效的连接请求报文段后，会误以为是 A 又发出一次新的连接请求，于是就向 A 发出确认报文段，同意建立连接，假定不采用第三次握手，那么只要 B 发出确认，新的连接就建立了，一直等待 A 发送数据过来，使得 B 的许多资源就浪费了，所以采用三次握手的方法可以防止上述现象的发生，在刚才的情况下，A 不会向 B 发出第二次确认，B 由于收不到确认，就知道 A 并没有要求建立连接

TCP 四次挥手：

TCP 连接的拆除需要发送四个包，客户端或者服务器端均可主动发起挥手动作，在 SOCKET 编程中，任何一方执行 close() 即可产生挥手操作

解释：当 A 没有数据要发送时，就要释放 A 这边的连接，A 会发送一个报文（没有数据），B 收到后会给应用程序一个信号，这时候 A 那边的连接已经关闭，即 A 不再发送信息（但仍可接收信息），A 收到 B 的确认后进入等待状态，等待 B 请求释放连接，B 数据发送完成后就向 A 请求连接释放，A 收到后回复一个确认信息，并等待2MSL 时间

为什么要等待呢？

考虑到这种情况，B 向 A 发送释放连接请求，但这个报文丢失了，A 没有接收到不会发送确认信息，B 超时会重传，这时 A 在等待时间内还能够接收到这个请求，再回复一个确认就行了

另外服务器 B 存在一个保活状态，如果 A 突然死机了，保活时间到了后，B 会发送探测信息，以决定是否释放连接

常见的状态代码、状态描述：

| 类型 |       类别       |            描述            |
| :--: | :--------------: | :------------------------: |
| 1 xx |   信息行状态码   |     接受的请求正在处理     |
| 2 xx |    成功状态码    |      请求正常处理完毕      |
| 3 xx |   重定向状态码   | 需要进行附加操作以完成请求 |
| 4 xx | 客户端错误状态码 |     服务器无法处理请求     |
| 5 xx | 服务器错误状态码 |     服务器处理请求出错     |

| 代码 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| 100  |                请求开始部分收到，可以继续请求                |
| 200  |                           请求成功                           |
| 201  |                        新的 URL 创建                         |
| 202  |                          请求被接受                          |
| 204  |                        主体中没有内容                        |
| 301  | 永久重定向。被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 |
| 302  | 临时重定向。请求的资源临时分配了新的 URL，本次暂且使用新的 URL |
| 304  | 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。（该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况） |
| 400  |                      请求中出现语法错误                      |
| 401  |                         请求未经授权                         |
| 403  |         服务被禁止。服务器收到请求，但是拒绝提供服务         |
| 404  |                       请求的资源不存在                       |
| 500  |                          服务器出错                          |
| 503  |     服务器当前不能处理客户端请求，一段时间后可能恢复正常     |

##### 6.为什么连接的时候是三次握手，关闭的时候却是四次握手？

少于三次握手都不能确定双方是否连接并且可以相互发消息；多于三次，就是浪费了

##### 7.HTTP 缓存

**Expires**

Expires 指缓存过期的时间，超过了这个时间点就代表资源过期。有一个问题是由于使用具体时间，如果时间表示出错或者没有转换到正确的时区都可能造成缓存生命周期出错。并且 Expires 是 HTTP/1.0 的标准，现在更倾向于用 HTTP/1.1 中定义的 Cache-Control。两个同时存在时也是 Cache-Control 的优先级更高。

| 缓存策略类型 |          缓存策略值           |                             结果                             | 备注 |
| :----------: | :---------------------------: | :----------------------------------------------------------: | :--: |
| 缓存存储策略 | cache-control：public/private |                   响应数据会被缓存到客户端                   |      |
| 缓存过期策略 |            Expires            |       立马过期，二次资源访问浏览器会重新发起 HTTP 请求       |      |
| 缓存对比策略 |         Last-modified         | 浏览器会携带该值去服务器端对比，对比成功则返回 304，服务器端提示浏览器从本地加载数据，否则返回 200 并响应数据 |      |

|   用户操作   |  Expires/Cache-Control  |    Last-Modified/Etag    |
| :----------: | :---------------------: | :----------------------: |
|  地址栏回车  |          有效           |           有效           |
| 页面链接跳转 |          有效           |           有效           |
|   新开窗口   |          有效           |           有效           |
|  前进、后退  |          有效           |           有效           |
|    F5刷新    |  无效(BR重置max-age=0)  |           有效           |
| Ctrl+F5刷新  | 无效（重置CC=no-cache） | 无效（请求头丢弃该选项） |

##### 8.HTTP 缓存机制

 [彻底弄懂HTTP缓存机制及原理](http://www.cnblogs.com/chenqf/p/6386163.html)

> ######总结
>
> 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
>
> 对于比较缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**浏览器第一次请求：**

![浏览器第一次请求](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210142134291-1976923079.png)

**浏览器再次请求时：**

![浏览器再次请求时](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)

##### 9.XSS 攻击及防御

**XSS 攻击的原理：**XSS 表示 Cross Site Scripting (跨站脚本攻击)，它与 SQL 注入攻击类似，SQL 注入攻击中以 SQL 语句作为用户输入，从而达到查询/修改/删除数据的目的，而在 XSS 攻击中，通过插入恶意脚本，实现对用户游览器的控制。

XSS 攻击主要用户攻击者盗取用户的 cookie，由于 sessionId 是存储在 cookie 中的，当攻击者获取了用户的 cookie，则攻击者可以在 session 的生命周期内，达到获取被攻击用户的用户权限。

XSS 攻击可以分成两类：

* 非持久型攻击
* 持久型攻击

XSS 的防御

* HttpOnly 防止劫取 Cookie
* 输入检查 XSS Filter
* 输出检查

当不对doctype进行定义时，会触发怪异模式。

* **在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)**
* **在怪异模式下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）**


